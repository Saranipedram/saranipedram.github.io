[{"title":"EndpointSlice در Kubernetes: چرا ساخته شد و دقیقاً چه مشکلی را حل می‌کند؟","permalink":"https://saranipedram.github.io/fa/2026/01/endpointslice-%D8%AF%D8%B1-kubernetes-%DA%86%D8%B1%D8%A7-%D8%B3%D8%A7%D8%AE%D8%AA%D9%87-%D8%B4%D8%AF-%D9%88-%D8%AF%D9%82%DB%8C%D9%82%D8%A7%D9%8B-%DA%86%D9%87-%D9%85%D8%B4%DA%A9%D9%84%DB%8C-%D8%B1%D8%A7-%D8%AD%D9%84-%D9%85%DB%8C%DA%A9%D9%86%D8%AF/","summary":"وقتی تعداد Podهای پشت یک Service زیاد می‌شود، «لیست backendها» مدام تغییر می‌کند: یکی آماده می‌شود، یکی terminate می‌شود، یکی جابه‌جا می‌شود. سال‌ها این لیست داخل آبجکت Endpoints نگه‌داری می‌شد؛ اما برای کلاسترهای بزرگ، یک آبجکت واحدِ بزرگ و پُر-آپدیت، هم برای کنترل‌پلین و هم برای مصرف‌کننده‌ها (مثل kube-proxy) به‌صرفه نیست.\nاینجاست که EndpointSlice وارد می‌شود: همان اطلاعات را نگه می‌دارد، ولی به‌جای یک آبجکت حجیم، آن را به چند «برش» کوچک‌تر تقسیم می‌کند تا مقیاس‌پذیری بهتر شود.\n","content":"وقتی تعداد Podهای پشت یک Service زیاد می‌شود، «لیست backendها» مدام تغییر می‌کند: یکی آماده می‌شود، یکی terminate می‌شود، یکی جابه‌جا می‌شود. سال‌ها این لیست داخل آبجکت Endpoints نگه‌داری می‌شد؛ اما برای کلاسترهای بزرگ، یک آبجکت واحدِ بزرگ و پُر-آپدیت، هم برای کنترل‌پلین و هم برای مصرف‌کننده‌ها (مثل kube-proxy) به‌صرفه نیست.\nاینجاست که EndpointSlice وارد می‌شود: همان اطلاعات را نگه می‌دارد، ولی به‌جای یک آبجکت حجیم، آن را به چند «برش» کوچک‌تر تقسیم می‌کند تا مقیاس‌پذیری بهتر شود.\nEndpointSlice چیست؟ EndpointSlice یک آبجکت در Kubernetes است که زیرمجموعه‌ای از endpointهای یک Service را نگه می‌دارد. معمولاً کنترلر Kubernetes خودش آن را می‌سازد و آپدیت می‌کند.\nنکته‌ی کلیدی: معیار اینجا endpoint است (یعنی آدرس/پورت قابل سرویس‌دهی)، نه صرفاً تعداد Podها. در حالت رایج، تقریباً هر Pod یک endpoint می‌شود.\nچرا Endpoints کافی نبود؟ مشکل اصلی Endpoints این بود که:\nیک Service معمولاً یک آبجکت Endpoints داشت هر تغییر کوچک در backendها باعث آپدیت همان آبجکت می‌شد با زیاد شدن endpointها، حجم payloadها بزرگ می‌شد و churn بالا می‌رفت این موضوع در سرویس‌های کوچک (مثلاً زیر ۲۰ Pod) خیلی به چشم نمی‌آید؛ ولی در سرویس‌های بزرگ یا کلاسترهای پرترافیک، هزینه‌ها جمع می‌شوند.\nقانون ۱۰۰ تا: هر EndpointSlice چند backend را نگه می‌دارد؟ به‌صورت پیش‌فرض، هر EndpointSlice بیشتر از ۱۰۰ endpoint را نگه نمی‌دارد. یعنی اگر پشت یک Service مثلاً ۱۰۵ endpoint داشته باشی، معمولاً دو EndpointSlice می‌بینی: یکی حدود ۱۰۰تایی و یکی با ۵ endpoint.\nپس اگر ۹۹ endpoint داشته باشی، معمولاً فقط یک EndpointSlice خواهی داشت.\nیک نگاه سریع به ساختار EndpointSlice هر EndpointSlice معمولاً این بخش‌ها را دارد:\nmetadata.labels.kubernetes.io/service-name: مشخص می‌کند متعلق به کدام Service است addressType: معمولاً IPv4 یا IPv6 ports: پورت(های) سرویس endpoints: لیست backendها (آدرس‌ها + شرایط + targetRef) در endpoints معمولاً برای هر backend چیزی شبیه این می‌بینی:\naddresses: IP پاد conditions: وضعیت‌هایی مثل ready / serving / terminating targetRef: اشاره به Pod مربوطه (اسم/namespace/uid) مثال عملی: دیدن EndpointSliceهای سرویس nginx فرض کن namespace ما default است و Service ما nginx.\nاول مطمئن شو Service وجود دارد:\n1 kubectl get svc nginx -n default -o wide حالا EndpointSliceهای مربوط به آن را ببین:\n1 kubectl get endpointslice -n default -l kubernetes.io/service-name=nginx -o wide برای دیدن جزئیات کامل (آدرس‌ها، پورت‌ها، شرایط، و targetRef):\n1 kubectl describe endpointslice -n default -l kubernetes.io/service-name=nginx یک نکته واقعی از میدان جنگ خیلی‌ها دفعه اول تلاش می‌کنند با jsonpath تعداد endpointها را بشمارند و به len() می‌خورند:\n1 kubectl get endpointslice -n default -l kubernetes.io/service-name=nginx -o jsonpath=\u0026#39;{range .items[*]}{.metadata.name}{\u0026#34; endpoints=\u0026#34;}{len(.endpoints)}{\u0026#34;\\n\u0026#34;}{end}\u0026#39; و جواب می‌گیرد که len شناخته نیست، چون kubectl jsonpath تابع len() ندارد.\nاگر روی سیستم jq داری، این روش تمیزترین راه برای شمارش است:\n1 kubectl get endpointslice -n default -l kubernetes.io/service-name=nginx -o json | jq -r \u0026#39;.items[] | \u0026#34;\\(.metadata.name) endpoints=\\(.endpoints|length)\u0026#34;\u0026#39; اگر jq نداری و نمی‌خوای نصب کنی، یک شمارش تقریبی (ولی معمولاً درست) این است:\n1 kubectl get endpointslice -n default -l kubernetes.io/service-name=nginx -o yaml | grep -c \u0026#39;targetRef:\u0026#39; چه زمانی واقعاً چند EndpointSlice می‌بینم؟ زمانی که تعداد endpointها از سقف هر Slice عبور کند.\nبرای دیدن این حالت باید تعداد backendها را بالا ببری. اگر Deployment مربوطه را داری:\n1 2 kubectl get deploy -n default | grep -i nginx kubectl scale deploy/\u0026lt;deployment-name\u0026gt; -n default --replicas=105 بعد دوباره لیست Sliceها را بگیر:\n1 kubectl get endpointslice -n default -l kubernetes.io/service-name=nginx -o wide در حالت معمول باید بیش از یک EndpointSlice ببینی.\nمزیت اصلی EndpointSlice دقیقاً چیست؟ EndpointSlice قرار نیست برای سرویس‌های ۵ تا ۲۰ پادی «معجزه» بسازد. ارزشش وقتی روشن می‌شود که:\nیک سرویس endpointهای خیلی زیاد دارد یا کلاستر از نظر تعداد سرویس/تغییرات، شلوغ است در مدل Endpoints، یک تغییر کوچک می‌تواند باعث آپدیت یک آبجکت بزرگ شود.\nدر مدل EndpointSlice، همان تغییر معمولاً فقط روی یکی از Sliceهای کوچک اثر می‌گذارد. یعنی به‌جای جابه‌جا کردن یک payload بزرگ، چند payload کوچک‌تر جابه‌جا می‌شود و فشار روی apiserver و watcherها کمتر می‌شود.\nبرداشت‌های اشتباه رایج Endpoint با Pod یکی نیست: معمولاً هم‌پوشانی دارد، ولی معیار endpoint «آدرس قابل سرویس‌دهی» است. اگر سرویس کوچک باشد، فقط یک Slice می‌بینی: کاملاً طبیعی است. دو-استک (IPv4/IPv6): ممکن است برای یک سرویس Sliceهای جداگانه ببینی، حتی اگر تعداد Podها کم باشد. جمع‌بندی EndpointSlice همان ایده‌ی قدیمی کشف سرویس را نگه می‌دارد، ولی آن را برای مقیاس‌های بزرگ‌تر قابل‌تحمل‌تر می‌کند.\nبرای سرویس‌های عادی تفاوت زیادی حس نمی‌شود، اما برای سرویس‌های بزرگ و کلاسترهای پرچِرن، تفاوت از جنس «کنترل‌پلین نفس می‌کشد» است.\nدر پایان، اگر دنبال یک چک‌لیست دیباگ سریع هستی:\nkubectl get endpointslice kubectl describe endpointslice مقایسه با kubectl get endpoints nginx -o yaml "},{"title":"Hello Kubernetes","permalink":"https://saranipedram.github.io/fa/2026/01/hello-kubernetes/","summary":"شروع سریع و تمیز برای Kubernetes.","content":"اینجا متن پست فارسی میاد. مثلاً یک نمونه YAML:\n1 2 3 4 5 6 7 8 apiVersion: v1 kind: Pod metadata: name: demo spec: containers: - name: app image: nginx "},{"title":"جستجو","permalink":"https://saranipedram.github.io/fa/search/","summary":"","content":""},{"title":"درباره","permalink":"https://saranipedram.github.io/fa/about/","summary":" اینجا درباره‌ی من و این سایت می‌نویسم.\n","content":" اینجا درباره‌ی من و این سایت می‌نویسم.\n"}]