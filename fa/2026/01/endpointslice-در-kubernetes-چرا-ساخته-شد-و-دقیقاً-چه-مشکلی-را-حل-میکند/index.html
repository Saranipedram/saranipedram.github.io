<!doctype html><html lang=fa dir=rtl><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="وقتی تعداد Podهای پشت یک Service زیاد می\u200cشود، «لیست backendها» مدام تغییر می\u200cکند: یکی آماده می\u200cشود، یکی terminate می\u200cشود، یکی جابه\u200cجا می\u200cشود. سال\u200cها این لیست داخل آبجکت Endpoints نگه\u200cداری می\u200cشد؛ اما برای کلاسترهای بزرگ، یک آبجکت واحدِ بزرگ و پُر-آپدیت، هم برای کنترل\u200cپلین و هم برای مصرف\u200cکننده\u200cها (مثل kube-proxy) به\u200cصرفه نیست.\nاینجاست که EndpointSlice وارد می\u200cشود: همان اطلاعات را نگه می\u200cدارد، ولی به\u200cجای یک آبجکت حجیم، آن را به چند «برش» کوچک\u200cتر تقسیم می\u200cکند تا مقیاس\u200cپذیری بهتر شود.\n"><title>EndpointSlice در Kubernetes: چرا ساخته شد و دقیقاً چه مشکلی را حل می‌کند؟</title><link rel=canonical href=https://saranipedram.github.io/fa/2026/01/endpointslice-%D8%AF%D8%B1-kubernetes-%DA%86%D8%B1%D8%A7-%D8%B3%D8%A7%D8%AE%D8%AA%D9%87-%D8%B4%D8%AF-%D9%88-%D8%AF%D9%82%DB%8C%D9%82%D8%A7%D9%8B-%DA%86%D9%87-%D9%85%D8%B4%DA%A9%D9%84%DB%8C-%D8%B1%D8%A7-%D8%AD%D9%84-%D9%85%DB%8C%DA%A9%D9%86%D8%AF/><link rel=stylesheet href=/scss/style.min.833d6eed45de56f48306bf57268d5b8cdfc8a60e8e7bdc99810464fcd033f7c6.css><meta property='og:title' content="EndpointSlice در Kubernetes: چرا ساخته شد و دقیقاً چه مشکلی را حل می\u200cکند؟"><meta property='og:description' content="وقتی تعداد Podهای پشت یک Service زیاد می\u200cشود، «لیست backendها» مدام تغییر می\u200cکند: یکی آماده می\u200cشود، یکی terminate می\u200cشود، یکی جابه\u200cجا می\u200cشود. سال\u200cها این لیست داخل آبجکت Endpoints نگه\u200cداری می\u200cشد؛ اما برای کلاسترهای بزرگ، یک آبجکت واحدِ بزرگ و پُر-آپدیت، هم برای کنترل\u200cپلین و هم برای مصرف\u200cکننده\u200cها (مثل kube-proxy) به\u200cصرفه نیست.\nاینجاست که EndpointSlice وارد می\u200cشود: همان اطلاعات را نگه می\u200cدارد، ولی به\u200cجای یک آبجکت حجیم، آن را به چند «برش» کوچک\u200cتر تقسیم می\u200cکند تا مقیاس\u200cپذیری بهتر شود.\n"><meta property='og:url' content='https://saranipedram.github.io/fa/2026/01/endpointslice-%D8%AF%D8%B1-kubernetes-%DA%86%D8%B1%D8%A7-%D8%B3%D8%A7%D8%AE%D8%AA%D9%87-%D8%B4%D8%AF-%D9%88-%D8%AF%D9%82%DB%8C%D9%82%D8%A7%D9%8B-%DA%86%D9%87-%D9%85%D8%B4%DA%A9%D9%84%DB%8C-%D8%B1%D8%A7-%D8%AD%D9%84-%D9%85%DB%8C%DA%A9%D9%86%D8%AF/'><meta property='og:site_name' content='یادداشت‌ها — Kubernetes و SRE'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='kubernetes'><meta property='article:tag' content='networking'><meta property='article:tag' content='sre'><meta property='article:tag' content='service-discovery'><meta property='article:published_time' content='2026-01-06T00:00:00+00:00'><meta property='article:modified_time' content='2026-01-06T00:00:00+00:00'><meta name=twitter:title content="EndpointSlice در Kubernetes: چرا ساخته شد و دقیقاً چه مشکلی را حل می\u200cکند؟"><meta name=twitter:description content="وقتی تعداد Podهای پشت یک Service زیاد می\u200cشود، «لیست backendها» مدام تغییر می\u200cکند: یکی آماده می\u200cشود، یکی terminate می\u200cشود، یکی جابه\u200cجا می\u200cشود. سال\u200cها این لیست داخل آبجکت Endpoints نگه\u200cداری می\u200cشد؛ اما برای کلاسترهای بزرگ، یک آبجکت واحدِ بزرگ و پُر-آپدیت، هم برای کنترل\u200cپلین و هم برای مصرف\u200cکننده\u200cها (مثل kube-proxy) به\u200cصرفه نیست.\nاینجاست که EndpointSlice وارد می\u200cشود: همان اطلاعات را نگه می\u200cدارد، ولی به\u200cجای یک آبجکت حجیم، آن را به چند «برش» کوچک\u200cتر تقسیم می\u200cکند تا مقیاس\u200cپذیری بهتر شود.\n"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=منو>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/fa/><img src=/img/avatar_hu_b5976aa1afdc1d2e.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/fa>یادداشت‌ها — Kubernetes و SRE</a></h1><h2 class=site-description></h2></div></header><ol class=menu id=main-menu><li><a href=/><span>خانه</span></a></li><li><a href=about/><span>درباره</span></a></li><li><a href=runbook/><span>Runbook</span></a></li><li><a href=postmortem/><span>Postmortem</span></a></li><li><a href=search/><span>جستجو</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://saranipedram.github.io/fa/ selected>فارسی</option><option value=https://saranipedram.github.io/en/>English</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>حالت شب</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/fa/categories/kubernetes/>Kubernetes</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/fa/2026/01/endpointslice-%D8%AF%D8%B1-kubernetes-%DA%86%D8%B1%D8%A7-%D8%B3%D8%A7%D8%AE%D8%AA%D9%87-%D8%B4%D8%AF-%D9%88-%D8%AF%D9%82%DB%8C%D9%82%D8%A7%D9%8B-%DA%86%D9%87-%D9%85%D8%B4%DA%A9%D9%84%DB%8C-%D8%B1%D8%A7-%D8%AD%D9%84-%D9%85%DB%8C%DA%A9%D9%86%D8%AF/>EndpointSlice در Kubernetes: چرا ساخته شد و دقیقاً چه مشکلی را حل می‌کند؟</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2026-01-06T00:00:00Z>ژانویهٔ 06, 2026</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>مطالعه در 4 دقیقه</time></div></footer></div></header><section class=article-content><p>وقتی تعداد Podهای پشت یک Service زیاد می‌شود، «لیست backendها» مدام تغییر می‌کند: یکی آماده می‌شود، یکی terminate می‌شود، یکی جابه‌جا می‌شود. سال‌ها این لیست داخل آبجکت <code>Endpoints</code> نگه‌داری می‌شد؛ اما برای کلاسترهای بزرگ، یک آبجکت واحدِ بزرگ و پُر-آپدیت، هم برای کنترل‌پلین و هم برای مصرف‌کننده‌ها (مثل kube-proxy) به‌صرفه نیست.</p><p>اینجاست که <strong>EndpointSlice</strong> وارد می‌شود: همان اطلاعات را نگه می‌دارد، ولی به‌جای یک آبجکت حجیم، آن را به چند «برش» کوچک‌تر تقسیم می‌کند تا مقیاس‌پذیری بهتر شود.</p><h2 id=endpointslice-چیست>EndpointSlice چیست؟</h2><p><code>EndpointSlice</code> یک آبجکت در Kubernetes است که زیرمجموعه‌ای از endpointهای یک Service را نگه می‌دارد. معمولاً کنترلر Kubernetes خودش آن را می‌سازد و آپدیت می‌کند.</p><p>نکته‌ی کلیدی: معیار اینجا <strong>endpoint</strong> است (یعنی آدرس/پورت قابل سرویس‌دهی)، نه صرفاً تعداد Podها. در حالت رایج، تقریباً هر Pod یک endpoint می‌شود.</p><h2 id=چرا-endpoints-کافی-نبود>چرا Endpoints کافی نبود؟</h2><p>مشکل اصلی <code>Endpoints</code> این بود که:</p><ul><li>یک Service معمولاً یک آبجکت Endpoints داشت</li><li>هر تغییر کوچک در backendها باعث آپدیت همان آبجکت می‌شد</li><li>با زیاد شدن endpointها، حجم payloadها بزرگ می‌شد و churn بالا می‌رفت</li></ul><p>این موضوع در سرویس‌های کوچک (مثلاً زیر ۲۰ Pod) خیلی به چشم نمی‌آید؛ ولی در سرویس‌های بزرگ یا کلاسترهای پرترافیک، هزینه‌ها جمع می‌شوند.</p><h2 id=قانون-۱۰۰-تا-هر-endpointslice-چند-backend-را-نگه-میدارد>قانون ۱۰۰ تا: هر EndpointSlice چند backend را نگه می‌دارد؟</h2><p>به‌صورت پیش‌فرض، هر EndpointSlice بیشتر از <strong>۱۰۰ endpoint</strong> را نگه نمی‌دارد. یعنی اگر پشت یک Service مثلاً ۱۰۵ endpoint داشته باشی، معمولاً دو EndpointSlice می‌بینی: یکی حدود ۱۰۰تایی و یکی با ۵ endpoint.</p><p>پس اگر ۹۹ endpoint داشته باشی، معمولاً فقط <strong>یک EndpointSlice</strong> خواهی داشت.</p><h2 id=یک-نگاه-سریع-به-ساختار-endpointslice>یک نگاه سریع به ساختار EndpointSlice</h2><p>هر EndpointSlice معمولاً این بخش‌ها را دارد:</p><ul><li><code>metadata.labels.kubernetes.io/service-name</code>: مشخص می‌کند متعلق به کدام Service است</li><li><code>addressType</code>: معمولاً <code>IPv4</code> یا <code>IPv6</code></li><li><code>ports</code>: پورت(های) سرویس</li><li><code>endpoints</code>: لیست backendها (آدرس‌ها + شرایط + targetRef)</li></ul><p>در <code>endpoints</code> معمولاً برای هر backend چیزی شبیه این می‌بینی:</p><ul><li><code>addresses</code>: IP پاد</li><li><code>conditions</code>: وضعیت‌هایی مثل <code>ready</code> / <code>serving</code> / <code>terminating</code></li><li><code>targetRef</code>: اشاره به Pod مربوطه (اسم/namespace/uid)</li></ul><h2 id=مثال-عملی-دیدن-endpointsliceهای-سرویس-nginx>مثال عملی: دیدن EndpointSliceهای سرویس nginx</h2><p>فرض کن namespace ما <code>default</code> است و Service ما <code>nginx</code>.</p><p>اول مطمئن شو Service وجود دارد:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get svc nginx -n default -o wide
</span></span></code></pre></td></tr></table></div></div><p>حالا EndpointSliceهای مربوط به آن را ببین:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get endpointslice -n default -l kubernetes.io/service-name<span class=o>=</span>nginx -o wide
</span></span></code></pre></td></tr></table></div></div><p>برای دیدن جزئیات کامل (آدرس‌ها، پورت‌ها، شرایط، و targetRef):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl describe endpointslice -n default -l kubernetes.io/service-name<span class=o>=</span>nginx
</span></span></code></pre></td></tr></table></div></div><h3 id=یک-نکته-واقعی-از-میدان-جنگ>یک نکته واقعی از میدان جنگ</h3><p>خیلی‌ها دفعه اول تلاش می‌کنند با <code>jsonpath</code> تعداد endpointها را بشمارند و به <code>len()</code> می‌خورند:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get endpointslice -n default -l kubernetes.io/service-name<span class=o>=</span>nginx   -o <span class=nv>jsonpath</span><span class=o>=</span><span class=s1>&#39;{range .items[*]}{.metadata.name}{&#34; endpoints=&#34;}{len(.endpoints)}{&#34;\n&#34;}{end}&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>و جواب می‌گیرد که <code>len</code> شناخته نیست، چون <code>kubectl jsonpath</code> تابع <code>len()</code> ندارد.</p><p>اگر روی سیستم <code>jq</code> داری، این روش تمیزترین راه برای شمارش است:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get endpointslice -n default -l kubernetes.io/service-name<span class=o>=</span>nginx -o json   <span class=p>|</span> jq -r <span class=s1>&#39;.items[] | &#34;\(.metadata.name) endpoints=\(.endpoints|length)&#34;&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>اگر <code>jq</code> نداری و نمی‌خوای نصب کنی، یک شمارش تقریبی (ولی معمولاً درست) این است:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get endpointslice -n default -l kubernetes.io/service-name<span class=o>=</span>nginx -o yaml <span class=p>|</span> grep -c <span class=s1>&#39;targetRef:&#39;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=چه-زمانی-واقعا-چند-endpointslice-میبینم>چه زمانی واقعاً چند EndpointSlice می‌بینم؟</h2><p>زمانی که تعداد endpointها از سقف هر Slice عبور کند.</p><p>برای دیدن این حالت باید تعداد backendها را بالا ببری. اگر Deployment مربوطه را داری:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get deploy -n default <span class=p>|</span> grep -i nginx
</span></span><span class=line><span class=cl>kubectl scale deploy/&lt;deployment-name&gt; -n default --replicas<span class=o>=</span><span class=m>105</span>
</span></span></code></pre></td></tr></table></div></div><p>بعد دوباره لیست Sliceها را بگیر:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get endpointslice -n default -l kubernetes.io/service-name<span class=o>=</span>nginx -o wide
</span></span></code></pre></td></tr></table></div></div><p>در حالت معمول باید بیش از یک EndpointSlice ببینی.</p><h2 id=مزیت-اصلی-endpointslice-دقیقا-چیست>مزیت اصلی EndpointSlice دقیقاً چیست؟</h2><p>EndpointSlice قرار نیست برای سرویس‌های ۵ تا ۲۰ پادی «معجزه» بسازد. ارزشش وقتی روشن می‌شود که:</p><ul><li>یک سرویس endpointهای خیلی زیاد دارد</li><li>یا کلاستر از نظر تعداد سرویس/تغییرات، شلوغ است</li></ul><p>در مدل Endpoints، یک تغییر کوچک می‌تواند باعث آپدیت یک آبجکت بزرگ شود.<br>در مدل EndpointSlice، همان تغییر معمولاً فقط روی یکی از Sliceهای کوچک اثر می‌گذارد. یعنی به‌جای جابه‌جا کردن یک payload بزرگ، چند payload کوچک‌تر جابه‌جا می‌شود و فشار روی apiserver و watcherها کمتر می‌شود.</p><h2 id=برداشتهای-اشتباه-رایج>برداشت‌های اشتباه رایج</h2><ul><li>Endpoint با Pod یکی نیست: معمولاً هم‌پوشانی دارد، ولی معیار endpoint «آدرس قابل سرویس‌دهی» است.</li><li>اگر سرویس کوچک باشد، فقط یک Slice می‌بینی: کاملاً طبیعی است.</li><li>دو-استک (IPv4/IPv6): ممکن است برای یک سرویس Sliceهای جداگانه ببینی، حتی اگر تعداد Podها کم باشد.</li></ul><h2 id=جمعبندی>جمع‌بندی</h2><p>EndpointSlice همان ایده‌ی قدیمی کشف سرویس را نگه می‌دارد، ولی آن را برای مقیاس‌های بزرگ‌تر قابل‌تحمل‌تر می‌کند.<br>برای سرویس‌های عادی تفاوت زیادی حس نمی‌شود، اما برای سرویس‌های بزرگ و کلاسترهای پرچِرن، تفاوت از جنس «کنترل‌پلین نفس می‌کشد» است.</p><p>در پایان، اگر دنبال یک چک‌لیست دیباگ سریع هستی:</p><ul><li><code>kubectl get endpointslice</code></li><li><code>kubectl describe endpointslice</code></li><li>مقایسه با <code>kubectl get endpoints nginx -o yaml</code></li></ul></section><footer class=article-footer><section class=article-tags><a href=/fa/tags/kubernetes/>Kubernetes</a>
<a href=/fa/tags/networking/>Networking</a>
<a href=/fa/tags/sre/>Sre</a>
<a href=/fa/tags/service-discovery/>Service-Discovery</a></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2026 یادداشت‌ها — Kubernetes و SRE</section><section class=powerby>قدرت گرفته از <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>قالب <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.33.0>Stack</a></b> ساخته شده توسط <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>